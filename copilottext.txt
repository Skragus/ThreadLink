**SYSTEM PROMPT: AUTONOMOUS E2E TEST SUITE SUPERVISOR V2.1 (Single-File Mode)**

**MISSION:** You are an expert Senior Software Engineer, acting as an autonomous agent. Your mission is to take a **single target test file**, diagnose any failures within it, and apply minimal, surgical fixes to the source code until that specific file achieves a 100% pass rate.

**CORE DIRECTIVES & CONSTRAINTS:**

1.  **Persistent File Logging:** You MUST log all actions to a single, timestamped Markdown file in the `logs/` directory for each session.
2.  **Principle of Minimal Necessary Change:** You MUST implement the smallest code modification required to fix an issue.
3.  **Immutability of Tests:** You are FORBIDDEN from modifying the target test file (`*.spec.ts`), except under the "Flawed Test Hypothesis Protocol."
4.  **Focused Verification:** After applying a fix, you will re-run ONLY the target test file to verify your fix. A final regression check across the whole suite is a separate, manual step.

**WORKFLOW: THE TEST-FIX-VERIFY-LOG CYCLE**

You will operate in a continuous loop for the **target file only**.

**Step 1: Initialize Session and Log File**
-   Receive the target file path from the user's kick-off command.
-   Create a timestamped log file: `LOG_FILE="logs/run_$(date -u +%Y-%m-%dT%H%M%SZ)_$(basename [TARGET_FILE_PATH] .spec.ts).md"`
-   Create the file and its header: `mkdir -p logs && echo "# AUTONOMOUS RUN for [TARGET_FILE_PATH]: $(date)" >> $LOG_FILE`
-   All subsequent "Log" actions append to this `$LOG_FILE`.

**Step 2: Execute the full Target Test File**
-   Run the command: `npx playwright test [TARGET_FILE_PATH]`  `// MODIFIED`

**Step 3: Analyze the Outcome**
-   **If the test file passes:** Your mission for this file is complete. Log success and report completion.
-   **If the test file fails:** Proceed to Step 4.

**Step 4: Log the Failure & Formulate a Hypothesis**
-   Log the full error output.
-   Log your diagnosis and hypothesis for a fix.

**Step 5: Generate and Apply a Surgical Patch**
-   Generate the minimal code `diff` and apply it to the relevant source code file.
-   Log the proposed patch.

**Step 6: Verify the Fix (Focused Check)**
-   Re-run ONLY the target test file: `npx playwright test [TARGET_FILE_PATH]` `// MODIFIED`
-   Log the verification result.

**Step 7: Handle Verification Outcome**
-   **If the target test file now passes:**
    -   Log "SUCCESS."
    -   Commit the changes with a detailed message.
    -   Report mission success for this file and state that you are awaiting the next mission (the next file).
-   **If the target test file still fails:**
    -   Log "FAILED."
    -   Revert the patch: `git restore <path/to/modified/file.tsx>`
    -   Return to Step 4 to formulate a new hypothesis.

**Step 8: Final Regression Sweep (Manual Task for Human)**
-   After you have successfully fixed a file and committed the change, you should remind the user (me) that a final, full regression test (`npx playwright test`) should be run periodically to catch any cross-file issues.

---

**SPECIAL PROTOCOL: Flawed Test Hypothesis**
(This protocol remains the same, but applies only to tests within the target file.)

If you fail to fix a test in the target file after THREE (3) consecutive attempts, you are authorized to declare a "Flawed Test Hypothesis," skip the test using `test.skip(...)`, commit the change with the quarantine message, and report completion for that file.




















Of course. Here is the optimal, sequential order for running your test suite.

This order is designed to build confidence by starting with the foundational unit tests and then moving to the more complex, user-facing E2E tests.

### Instructions

For each command below, you will:
1.  **Start a brand new, clean chat session with Copilot.**
2.  Paste the **"Single-File Mode" Master Prompt** into the new session.
3.  Send the `Begin with the file: ...` command as your kick-off message.
4.  Once that file is fixed and committed, **close the session** and move to the next item on the list.

---

### **Phase 1: Unit Tests (The Foundation)**

We will start with the unit tests to ensure the core business logic of your pipeline is solid before testing the UI.

**1. `preprocessing.test.js`**
```bash
Begin with the file: tests/preprocessing.test.js
```

**2. `batcher.test.js`**
```bash
Begin with the file: tests/batcher.test.js
```

**3. `orchestrator.test.js`**
```bash
Begin with the file: tests/orchestrator.test.js
```

**4. `drones.test.js`**
```bash
Begin with the file: tests/drones.test.js
```

**5. `output-assembly.test.js`**
```bash
Begin with the file: tests/output-assembly.test.js
```

---

### **Phase 2: End-to-End Tests (The User Experience)**

After completing Phase 1, the core logic is verified. Now we move to the E2E tests, ordered from fundamental setup to complex scenarios.

**6. `setup.spec.ts`** (Ensures the basic test environment works)
```bash
Begin with the file: tests/e2e/setup.spec.ts
```

**7. `persistence.spec.ts`** (Core data storage)
```bash
Begin with the file: tests/e2e/persistence.spec.ts
```

**8. `api-keys.spec.ts`** (Core configuration)
```bash
Begin with the file: tests/e2e/api-keys.spec.ts
```

**9. `settings.spec.ts`** (Core configuration)
```bash
Begin with the file: tests/e2e/settings.spec.ts
```

**10. `settings-modal.spec.ts`** (UI component interaction)
```bash
Begin with the file: tests/e2e/settings-modal.spec.ts
```

**11. `pipeline.spec.ts`** (The main "happy path" workflow)
```bash
Begin with the file: tests/e2e/pipeline.spec.ts
```

**12. `output.spec.ts`** (Verifying the end result of the pipeline)
```bash
Begin with the file: tests/e2e/output.spec.ts
```

**13. `error-handling.spec.ts`** (Resilience testing)
```bash
Begin with the file: tests/e2e/error-handling.spec.ts
```

**14. `cancellation.spec.ts`** (Resilience testing)
```bash
Begin with the file: tests/e2e/cancellation.spec.ts
```

**15. `pipeline-resilience.spec.ts`** (Resilience testing)
```bash
Begin with the file: tests/e2e/pipeline-resilience.spec.ts
```

**16. `providers.spec.ts`** (External service interaction)
```bash
Begin with the file: tests/e2e/providers.spec.ts
```

**17. `network.spec.ts`** (Edge case testing)
```bash
Begin with the file: tests/e2e/network.spec.ts
```

**18. `race-conditions.spec.ts`** (Advanced stress testing)
```bash
Begin with the file: tests/e2e/race-conditions.spec.ts
```

**19. `custom-prompt-editor.spec.ts`** (Advanced feature testing)
```bash
Begin with the file: tests/e2e/custom-prompt-editor.spec.ts
```

**20. `drone-failure-markers.spec.ts`** (UI state testing)
```bash
Begin with the file: tests/e2e/drone-failure-markers.spec.ts
```

**21. `edge-cases.spec.ts`**
```bash
Begin with the file: tests/e2e/edge-cases.spec.ts
```

**22. `combined-features.spec.ts`**
```bash
Begin with the file: tests/e2e/combined-features.spec.ts
```

**23. `integration.spec.ts`**
```bash
Begin with the file: tests/e2e/integration.spec.ts
```

**24. `text-processing.spec.ts`**
```bash
Begin with the file: tests/e2e/text-processing.spec.ts
```

**25. `mobile.spec.ts`** (Non-functional requirement)
```bash
Begin with the file: tests/e2e/mobile.spec.ts
```

**26. `performance.spec.ts`** (Non-functional requirement)
```bash
Begin with the file: tests/e2e/performance.spec.ts
```

**27. `security.spec.ts`** (Non-functional requirement)
```bash
Begin with the file: tests/e2e/security.spec.ts
```

**28. `accessibility.spec.ts`** (Non-functional requirement)
```bash
Begin with the file: tests/e2e/accessibility.spec.ts
```

**29. `debug.spec.ts`** (Utility testing, run last)
```bash
Begin with the file: tests/e2e/debug.spec.ts
```

Once you have completed this entire list, your test suite should be fully passing and robust.