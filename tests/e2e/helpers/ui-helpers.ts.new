// tests/e2e/helpers/ui-helpers.ts
import { Page } from '@playwright/test';

export class ThreadLinkPage {
  constructor(private _page: Page) {}
  
  // Locators
  get textEditor() {
    return this._page.getByPlaceholder(/paste.*conversation/i);
  }

  get condenseButton() {
    return this._page.getByRole('button', { name: 'Condense' });
  }

  get cancelButton() {
    return this._page.getByRole('button', { name: 'Cancel' });
  }

  get resetButton() {
    return this._page.getByRole('button', { name: 'Reset' });
  }

  get copyButton() {
    return this._page.getByRole('button', { name: 'Copy' });
  }

  get apiKeyButton() {
    return this._page.getByRole('button', { name: 'Manage API keys' });
  }

  get settingsButton() {
    return this._page.getByRole('button', { name: 'Open settings' });
  }

  get infoButton() {
    return this._page.getByRole('button', { name: 'Open help documentation' });
  }

  get loadingOverlay() {
    return this._page.locator('[data-testid="loading-overlay"]');
  }

  get progressBar() {
    return this._page.locator('[data-testid="progress-bar"], .progress-bar');
  }
  
  // Helper method to detect if we're on mobile
  async isMobileViewport() {
    const viewport = this._page.viewportSize();
    return viewport && viewport.width < 768; // Standard mobile breakpoint
  }

  // Actions with enhanced mobile support
  async pasteText(text: string) {
    console.log('üîÑ Test: Attempting to paste text into editor');
    
    // First, check if there's a reset button and if needed, use it
    try {
      // Check if the editor is already readonly - in that case we can't paste
      const isReadOnly = await this._page.evaluate(() => {
        const textarea = document.querySelector('textarea[placeholder*="paste"]');
        return textarea && textarea.hasAttribute('readonly');
      }).catch(() => false);
      
      if (isReadOnly) {
        console.log('‚ö†Ô∏è Test: Text editor is readonly, attempting to reset first');
        // If the editor is readonly, we need to reset first
        try {
          const resetButton = this._page.getByRole('button', { name: 'Reset' });
          const isMobile = await this.isMobileViewport();
          
          if (await resetButton.isVisible({ timeout: 5000 })) {
            if (isMobile) {
              await resetButton.tap({ force: true });
            } else {
              await resetButton.click({ force: true });
            }
            await this._page.waitForTimeout(1500); // Give the UI more time to update
            console.log('‚úÖ Test: Reset button clicked to clear readonly state');
          }
        } catch (e) {
          console.warn('‚ö†Ô∏è Test: Could not reset before pasting text:', e);
        }
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Test: Error checking readonly state:', e);
    }
    
    // Try forcibly focusing the editor before pasting
    try {
      await this._page.evaluate(() => {
        const textarea = document.querySelector('textarea[placeholder*="paste"]');
        if (textarea) {
          (textarea as HTMLTextAreaElement).focus();
          // Also attempt to forcibly remove readonly attribute if present
          textarea.removeAttribute('readonly');
        }
      });
      console.log('‚úÖ Test: Forced focus on text editor');
      
      // Give it a moment after focusing
      await this._page.waitForTimeout(500);
      
    } catch (focusError) {
      console.warn('‚ö†Ô∏è Test: Could not force focus:', focusError);
    }
    
    // Now attempt to paste the text with multiple retries if needed
    let attempts = 0;
    const maxAttempts = 3;
    const isMobile = await this.isMobileViewport();
    
    while (attempts < maxAttempts) {
      attempts++;
      
      try {
        if (isMobile) {
          await this.textEditor.tap({ timeout: 5000 });
        } else {
          await this.textEditor.click({ force: true, timeout: 5000 });
        }
        
        await this.textEditor.clear({ timeout: 5000 });
        await this.textEditor.fill(text, { timeout: isMobile ? 15000 : 8000 });
        console.log(`‚úÖ Test: Text pasted successfully on attempt ${attempts}`);
        return; // Success, exit the retry loop
      } catch (e) {
        console.error(`‚ö†Ô∏è Test: Error pasting text on attempt ${attempts}:`, e);
        
        if (attempts < maxAttempts) {
          // If there are more attempts, try to recover
          console.log('üîÑ Test: Retrying paste after a short wait');
          await this._page.waitForTimeout(1000);
          
          // Try another approach - direct DOM manipulation as fallback
          if (attempts === 2) {
            try {
              await this._page.evaluate((inputText) => {
                const textarea = document.querySelector('textarea[placeholder*="paste"]');
                if (textarea) {
                  // @ts-ignore - Set the value directly
                  textarea.value = inputText;
                  // Dispatch events to simulate user input
                  textarea.dispatchEvent(new Event('input', { bubbles: true }));
                  textarea.dispatchEvent(new Event('change', { bubbles: true }));
                }
              }, text);
              console.log('‚úÖ Test: Text pasted using direct DOM manipulation');
              return;
            } catch (clipboardError) {
              console.error('‚ö†Ô∏è Test: Error with DOM manipulation fallback:', clipboardError);
            }
          }
        }
      }
    }
    
    // If we reach here, all attempts failed
    throw new Error(`Failed to paste text after ${maxAttempts} attempts`);
  }

  async startProcessing() {
    console.log('üîÑ Test: About to click/tap Condense button');
    
    const isMobile = await this.isMobileViewport();
    
    // Use appropriate interaction for the device type
    if (isMobile) {
      await this.condenseButton.tap({ timeout: 10000 });
    } else {
      await this.condenseButton.click({ force: true, timeout: 10000 });
    }
    console.log('‚úÖ Test: Condense button interaction completed');
  }
  
  async cancelProcessing() {
    console.log('üîÑ Test: About to attempt cancellation');
    
    // Take screenshot of the current state
    await this._page.screenshot({ path: './test-results/pre-cancel-helper.png' });
    
    // Ensure we pause briefly to let the UI stabilize
    await this._page.waitForTimeout(1000);
    
    // Track success state
    let cancelSuccess = false;
    const isMobile = await this.isMobileViewport();
    
    // First try interacting directly with the cancel button - simplest approach
    try {
      // Look for any button containing "Cancel" text
      const cancelButtons = await this._page.getByRole('button').filter({ hasText: /cancel/i }).all();
      
      if (cancelButtons.length > 0) {
        console.log(`‚úÖ Test: Found ${cancelButtons.length} cancel button(s), interacting with the first one`);
        
        // Use appropriate interaction for device type
        if (isMobile) {
          await cancelButtons[0].tap({ force: true, timeout: 10000 });
        } else {
          await cancelButtons[0].click({ force: true, timeout: 10000 });
        }
        
        console.log('‚úÖ Test: Cancel button interaction completed successfully');
        await this._page.waitForTimeout(1000); // Wait longer for interaction to register
        cancelSuccess = true;
      }
    } catch (e) {
      console.log(`‚ö†Ô∏è Test: Direct cancel button approach failed: ${e}`);
    }
    
    // If the first approach didn't work, try alternative CSS selectors
    if (!cancelSuccess) {
      try {
        const selectors = [
          'button:has-text("Cancel")',
          '[data-testid="cancel-button"]',
          'button.cancel-button',
          'button[aria-label="Cancel"]',
          '[role="button"]:has-text("Cancel")',
          '.cancel-btn'
        ];
        
        for (const selector of selectors) {
          try {
            const count = await this._page.locator(selector).count();
            if (count > 0) {
              console.log(`‚úÖ Test: Found cancel button with selector: ${selector}`);
              
              if (isMobile) {
                await this._page.locator(selector).first().tap({ force: true, timeout: 10000 });
              } else {
                await this._page.locator(selector).first().click({ force: true, timeout: 10000 });
              }
              
              console.log('‚úÖ Test: Alternative cancel button interaction completed');
              await this._page.waitForTimeout(1500); // Wait longer for click to register
              cancelSuccess = true;
              break;
            }
          } catch (innerError) {
            // Continue to the next selector
          }
        }
      } catch (e) {
        console.log(`‚ö†Ô∏è Test: Alternative selector approach failed: ${e}`);
      }
    }
    
    // If all UI methods failed, try keyboard Escape as a last resort
    if (!cancelSuccess) {
      try {
        console.log('üîÑ Test: Trying keyboard Escape as last resort');
        await this._page.keyboard.press('Escape');
        console.log('‚úÖ Test: Sent Escape key');
        await this._page.waitForTimeout(1000);
      } catch (e) {
        console.log(`‚ö†Ô∏è Test: Escape key approach failed: ${e}`);
      }
    }
    
    // Take a screenshot after the cancellation attempt
    await this._page.screenshot({ path: './test-results/post-cancel-helper.png' });
    
    // If none of our methods worked, we should throw to fail the test
    if (!cancelSuccess) {
      throw new Error('Failed to cancel processing - no method succeeded');
    }
  }

  async waitForProcessingComplete(timeout = 60000) {
    console.log('üîÑ Test: Waiting for processing to complete');
    
    // Wait for the loading overlay to disappear
    await this._page.waitForSelector('[data-testid="loading-overlay"]', { state: 'hidden', timeout });
    // Wait for the stats display to appear (indicates completion)
    await this._page.locator('[data-testid="stats-display"]').waitFor({ state: 'visible', timeout });
    // Also wait for the copy button as a secondary confirmation
    await this.copyButton.waitFor({ state: 'visible', timeout: 10000 });
  }

  async getOutputText(): Promise<string> {
    return await this.textEditor.inputValue();
  }
  
  // API Key Management
  async addApiKey(provider: string, apiKey: string) {
    console.log(`üîë Test: Adding API key for provider: ${provider}`);
    
    // Check if we're on mobile
    const isMobile = await this.isMobileViewport();
    
    try {
      // Open API key modal with appropriate interaction
      if (isMobile) {
        await this.apiKeyButton.tap({ timeout: 10000 });
      } else {
        await this.apiKeyButton.click({ timeout: 10000 });
      }
      console.log('‚úÖ Test: API key button clicked/tapped');
      
      // Wait for the API key dialog to appear
      await this._page.getByRole('dialog', { name: /api.+key/i }).waitFor({ timeout: 10000 });
      console.log('‚úÖ Test: API key dialog appeared');
      
      // Find the input by id (e.g., "google-api-key", "openai-api-key", "anthropic-api-key")
      const providerInput = this._page.locator(`#${provider}-api-key`);
      await providerInput.fill(apiKey);
      console.log(`‚úÖ Test: Filled ${provider} API key input`);
      
      // Save the API key (cache will be auto-enabled for testing)
      const saveButton = this._page.getByRole('button', { name: 'Save' });
      
      // Use appropriate interaction for device type
      if (isMobile) {
        await saveButton.tap({ force: true, timeout: 10000 });
      } else {
        await saveButton.click({ force: true, timeout: 10000 });
      }
      console.log('‚úÖ Test: Save button clicked/tapped');
      
      // Wait for dialog to close
      await this._page.getByRole('dialog', { name: /api.+key/i }).waitFor({ state: 'hidden', timeout: 10000 })
        .catch(() => {
          console.log('‚ö†Ô∏è Test: Dialog did not close automatically, attempting to close it');
          // If the dialog doesn't close automatically, try to close it manually
          const closeButton = this._page.locator('dialog button:has-text("Close"), dialog .close-button');
          
          if (isMobile) {
            closeButton.tap({ force: true }).catch(() => {});
          } else {
            closeButton.click({ force: true }).catch(() => {});
          }
        });
    } catch (e) {
      console.error('‚ùå Test: Error adding API key via UI:', e);
      
      // Try localStorage as a fallback
      try {
        console.log('üîÑ Test: Attempting localStorage fallback for API key');
        
        await this._page.evaluate((p: string, k: string) => {
          localStorage.setItem(`threadlink_api_key_${p}`, k);
        }, provider, apiKey);
        
        // Reload page to apply key from localStorage
        await this._page.reload();
        await this._page.waitForLoadState('networkidle');
        
        console.log('‚úÖ Test: Added API key via localStorage fallback');
      } catch (fallbackError) {
        console.error('‚ùå Test: API key fallback also failed:', fallbackError);
        throw e; // Re-throw the original error
      }
    }
  }

  // Additional helper methods for mobile tests
  async setCompressionLevel(level: string) {
    const dropdown = this._page.locator('select[aria-label="Compression level"], select:has-text("Compression level")');
    await dropdown.selectOption(level);
  }

  async verifyAppState() {
    // Check that all critical UI elements are present and in the correct state
    await this.condenseButton.isVisible();
    await this.settingsButton.isVisible();
    await this.textEditor.isEnabled();
    
    // Return a boolean indicating if the app is in a valid state
    return true;
  }
}
