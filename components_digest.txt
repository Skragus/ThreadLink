

================================================================================// FILE: components/APIKeysModal.tsx
// components/APIKeysModal.tsx - API Keys Modal Component
const APIKeysModal: React.FC<APIKeysModalProps> = ({
  isOpen,
  googleAPIKey,
  openaiAPIKey,
  anthropicAPIKey,
  googleCacheEnabled,
  openaiCacheEnabled,
  anthropicCacheEnabled,
  setGoogleAPIKey,
  setOpenaiAPIKey,
  setAnthropicAPIKey,
  setGoogleCacheEnabled,
  setOpenaiCacheEnabled,
  setAnthropicCacheEnabled,
  onSave,
  onClose,
  onDeleteKey
}) => {
  if (!isOpen) return null;
  const renderAPIKeySection = (
    provider: 'google' | 'openai' | 'anthropic',
    label: string,
    placeholder: string,
    value: string,
    setValue: (key: string) => void,
    cacheEnabled: boolean,
    setCacheEnabled: (enabled: boolean) => void
  ) => (
    <div>
      <div>
        <label htmlFor={`${provider}-api-key`}>
          {label}
        </label>
        <div>
          <span>Save to Browser</span>
          <button
            onClick={() => setCacheEnabled(!cacheEnabled)}
            title={`Toggle browser storage for ${label}`}`}
          >
            <span`} />
          </button>
        </div>
      </div>
      <div>
        <input
          id={`${provider}-api-key`}
          type="password"
          placeholder={placeholder}
          value={value}
          onChange={(e) => setValue(e.target.value)}
        />
        <button
          onClick={() => onDeleteKey(provider)}
          title={`Clear ${label}`}
        >
          <Trash2 size={16} />
        </button>
      </div>
    </div>
  );
  return (
    <div>
      <div>
        <h3>API Key Management</h3>
        <div>
          {renderAPIKeySection(
            'google',
            'Google API Key',
            'AIza...',
            googleAPIKey,
            setGoogleAPIKey,
            googleCacheEnabled,
            setGoogleCacheEnabled
          )}
          {renderAPIKeySection(
            'openai',
            'OpenAI API Key',
            'sk-...',
            openaiAPIKey,
            setOpenaiAPIKey,
            openaiCacheEnabled,
            setOpenaiCacheEnabled
          )}
          {renderAPIKeySection(
            'anthropic',
            'Anthropic API Key',
            'sk-ant-...',
            anthropicAPIKey,
            setAnthropicAPIKey,
            anthropicCacheEnabled,
            setAnthropicCacheEnabled
          )}
        </div>
        <div>
          <button
            onClick={onSave || onClose}
          >
            Save
          </button>
          <button
            onClick={onClose}
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};
APIKeysModal;

// FILE: components/Footer.tsx
// components/Footer.tsx - Footer Component
const Footer: React.FC<FooterProps> = ({
  tokenCount,
  compressionRatio,
  onCompressionChange,
  inputText,
  isProcessed,
  isLoading,
  isCopied,
  onCondense,
  onCopy,
  onReset
}) => {
  return (
    <>
      <div>
        <div>
          <div>
            <div>
              <div>
                <span>{formatTokenCount(tokenCount)}</span>
                <span>•</span>
                <label htmlFor="compression-ratio-select">
                  Compression level:
                </label>
                <select
                  id="compression-ratio-select"
                  value={compressionRatio}
                  onChange={onCompressionChange}
                >
                  <option value="light">Light</option>
                  <option value="balanced">Balanced</option>
                  <option value="aggressive">Aggressive</option>
                </select>
              </div>
            </div>
            <div>
              {inputText && !isProcessed && (
                <button 
                  onClick={onCondense}
                  disabled={isLoading}`}
                >
                  {isLoading ? 'Processing...' : 'Condense'}
                </button>
              )}
              {isProcessed && (
                <>
                  <button 
                    onClick={onCopy}
                  >
                    <span>Copy</span>
                    {isCopied && (
                      <span>
                        ✓
                      </span>
                    )}
                  </button>
                  <button 
                    onClick={onReset}
                  >
                    Reset
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      </div>
      {}
      <div>
        <p>
          <span>Open Source</span>
          <span>·</span>
          <span>BYOK</span>
          <span>·</span>
          <span>Privacy-first</span>
        </p>
      </div>
    </>
  );
};
Footer;

// FILE: components/Header.tsx
// components/Header.tsx - Header Component
const Header: React.FC<HeaderProps> = ({ 
  onInfoClick, 
  onAPIKeysClick, 
  onSettingsClick 
}) => {
  return (
    <div>
      <div>
        <h1>
          <span>Thread</span>
          <span>Link</span>
        </h1>
        <p>
          Condense, copy, continue — without breaking flow.
        </p>
      </div>
      <div>
        <button 
          onClick={onInfoClick}
          aria-label="Open help documentation"
        >
          <Info size={20} />
        </button>
        <button 
          onClick={onAPIKeysClick}
          aria-label="Manage API keys"
        >
          <Key size={20} />
        </button>
        <button 
          onClick={onSettingsClick}
          aria-label="Open settings"
        >
          <Settings size={20} />
        </button>
      </div>
    </div>
  );
};
Header;

// FILE: components/InfoPanel.tsx
// components/InfoPanel.tsx - Info Panel Component
const InfoPanel: React.FC<InfoPanelProps> = ({
  isOpen,
  expandedSections,
  onToggleSection,
  onClose
}) => {
  if (!isOpen) return null;
  return (
    <div>
      <div>
        {}
        <div>
          <h2>ThreadLink User Guide</h2>
          <button
            onClick={onClose}
            aria-label="Close info panel"
          >
            <X size={20} />
          </button>
        </div>
        {}
        <div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('what')}
            >
              <Sparkles size={20} />
              <div>
                <h3>What is ThreadLink?</h3>
                <p>LLMs forget. ThreadLink doesn't.</p>
              </div>
              {expandedSections.what ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.what && (
              <div>
                <p>
                  Modern AI is powerful but fundamentally amnesiac. ThreadLink is the antidote. It's a high-signal engine that turns sprawling chat logs and raw text into a clean, portable context card.
                </p>
                <p>
                  Its purpose is to preserve your momentum. The moment you hit a session cap, need to switch models, or just want to archive a project's history without losing a single thought, ThreadLink is the tool you reach for. It's built for a single, seamless workflow:
                </p>
                <p>
                  <strong>Use it to:</strong>
                </p>
                <ul>
                  <li>Make a conversation with Claude seamlessly continue inside GPT.</li>
                  <li>Distill a 400,000-token project history into a briefing you can actually read.</li>
                  <li>Archive the complete context of a feature build.</li>
                  <li>Turn any messy data dump into actionable intelligence.</li>
                </ul>
                <p>
                  It's not just a summarizer. <strong>It's a memory implant for your work.</strong>
                </p>
              </div>
            )}
          </div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('howto')}
            >
              <Copy size={20} />
              <div>
                <h3>How to Use ThreadLink</h3>
                <p>Garbage In, Garbage Out.</p>
              </div>
              {expandedSections.howto ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.howto && (
              <div>
                <p>
                  The quality of your context card depends entirely on the quality of the text you provide. For best results, follow this simple process to capture a clean, complete session log.
                </p>
                <div>
                  <div>
                    <span>1</span>
                    <div>
                      <h4>Prepare the Interface</h4>
                      <p>Before copying, collapse any sidebars or panels in your AI chat application to minimize UI clutter.</p>
                    </div>
                  </div>
                  <div>
                    <span>2</span>
                    <div>
                      <h4>Load the Full History</h4>
                      <p>Most chat apps use lazy loading. Scroll all the way to the top of the conversation to ensure the entire history is loaded into the page.</p>
                    </div>
                  </div>
                  <div>
                    <span>3</span>
                    <div>
                      <h4>Select All</h4>
                      <p>Use your keyboard (<strong>Ctrl+A</strong> on Windows, <strong>Cmd+A</strong> on Mac) to select the entire conversation from top to bottom.</p>
                    </div>
                  </div>
                  <div>
                    <span>4</span>
                    <div>
                      <h4>Copy and Paste</h4>
                      <p>Copy the selected text (<strong>Ctrl+C</strong> / <strong>Cmd+C</strong>), paste it into ThreadLink, and you're ready to condense.</p>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('compression')}
            >
              <Package size={20} />
              <div>
                <h3>Understanding Compression</h3>
                <p>The Suitcase Analogy: Pillows vs. Gold Bricks</p>
              </div>
              {expandedSections.compression ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.compression && (
              <div>
                <p>
                  The effectiveness of condensation is a direct function of the source text's information density. The compression level you choose sets a target ratio, but the final output is determined by the content itself.
                </p>
                <ul>
                  <li><strong>Low-Density Text (Pillows):</strong> Rambling conversations or marketing copy can be compressed heavily (20:1 or more). There is a lot of "air" (redundancy) to squeeze out.</li>
                  <li><strong>High-Density Text (Gold Bricks):</strong> Source code or technical specifications resist aggressive compression. The system will prioritize preserving critical information over hitting an arbitrary ratio.</li>
                </ul>
                <div>
                  <h4>Compression Level Settings</h4>
                  <p>
                    This setting controls the summarization pressure your drones will apply.
                  </p>
                </div>
                <ul>
                  <li><strong>Light:</strong> Preserves nuance and detail. Best for content where every word matters.</li>
                  <li><strong>Balanced:</strong> Default setting. Optimal trade-off between brevity and completeness.</li>
                  <li><strong>Aggressive:</strong> Maximum compression. Ideal for extracting key points from verbose content.</li>
                </ul>
              </div>
            )}
          </div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('strategy')}
            >
              <Scale size={20} />
              <div>
                <h3>Context Card Strategy</h3>
                <p>Precision vs. Focus: The Core Trade-off</p>
              </div>
              {expandedSections.strategy ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.strategy && (
              <div>
                <p>
                  The size of your final context card is a strategic choice. There is no single "best" size; it's a trade-off between the richness of the context and the cost and focus of the next LLM session.
                </p>
                <ul>
                  <li><strong>Large Context Cards (e.g., 15k+ tokens):</strong> These act as <strong>high-fidelity archives</strong>. They are excellent for deep analysis or creating a comprehensive project bible, but can sometimes cause the receiving LLM to get lost in less relevant details.</li>
                  <li><strong>Small Context Cards (e.g., &lt; 5k tokens):</strong> These act as <strong>high-signal tactical briefings</strong>. They are cheaper, faster, and force the summary to focus only on the most critical information. The trade-off is that nuance and secondary context are deliberately sacrificed.</li>
                </ul>
                <div>
                  <h4>The Reality of "Soft Targets"</h4>
                  <p>
                    It is critical to understand that the compression level you set is a <strong>strong suggestion</strong>, not a hard command. Our testing has shown that models, especially on dense technical text, will <strong>exceed the target if they determine it's necessary to preserve critical context</strong>. This is a feature of the system's "context-first" philosophy.
                  </p>
                </div>
                <div>
                  <h4>How to Achieve Higher Compression</h4>
                  <p>
                    If your first context card is larger than desired, you have two primary strategies for achieving a more aggressive condensation:
                  </p>
                  <ol>
                    <li><strong>Pre-Filter Your Input (Manual):</strong> The most effective method. Before you click "Condense," manually delete sections of the source text that you know are less important—conversational filler, redundant examples, off-topic tangents. This focuses the drones' attention only on what truly matters.</li>
                    <li><strong>Recursive Condensation (The Two-Pass Method):</strong> For maximum compression, you can run ThreadLink on its own output. Take the first context card you generated, paste it back into ThreadLink as a new input, and condense it again.</li>
                  </ol>
                </div>
              </div>
            )}
          </div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('drones')}
            >
              <Bot size={20} />
              <div>
                <h3>Meet Your Drones</h3>
                <p>Every Model Has a Personality. Choose the Right Specialist.</p>
              </div>
              {expandedSections.drones ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.drones && (
              <div>
                <div>
                  <p>
                    Different AI models have distinct personalities and operational limits. Choosing the right one—and understanding how ThreadLink handles it—is critical for getting the result you want.
                  </p>
                </div>
                <div>
                  <div>
                    <h4>Google Gemini</h4>
                    <ul>
                      <li><strong>Personality:</strong> Tends to be verbose. Excels at preserving narrative flow but will often exceed its token target to provide rich, descriptive summaries.</li>
                      <li><strong>Speed:</strong> Very fast</li>
                    </ul>
                  </div>
                  <div>
                    <h4>OpenAI GPT</h4>
                    <ul>
                      <li><strong>Personality:</strong> Generally the most balanced approach. Follows instructions and constraints reliably, offering a good middle ground for most tasks.</li>
                      <li><strong>Speed:</strong> Fast</li>
                    </ul>
                  </div>
                  <div>
                    <h4>Anthropic Claude</h4>
                    <ul>
                      <li><strong>Personality:</strong> Precise and ruthlessly concise. It adheres well to token limits and will aggressively cut text to meet its target. Ideal for summaries where brevity is key.</li>
                      <li><strong>Speed:</strong> Slow</li>
                    </ul>
                  </div>
                </div>
                <div>
                  <h4>Processing Speed</h4>
                  <p>This setting controls how many drones are dispatched to work in parallel.</p>
                  <div>
                    <div>
                      <p><strong>Normal:</strong> The default, safe setting (e.g., 3 concurrent jobs). It's a balance of speed and reliability.</p>
                    </div>
                    <div>
                      <p><strong>Fast:</strong> A more aggressive setting (e.g., 6 concurrent jobs). It can significantly speed up processing on large sessions but increases the risk of hitting API rate limits.</p>
                    </div>
                    <div>
                      <p><strong>A Note on Anthropic:</strong> Claude's API has very strict rate limits. To ensure your job completes successfully, ThreadLink automatically disables the "Fast" setting and processes jobs one at a time.</p>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('recency')}
            >
              <Focus size={20} />
              <div>
                <h3>Recency Mode: The Temporal Zoom Lens</h3>
                <p>Focus on What Matters Now.</p>
              </div>
              {expandedSections.recency ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.recency && (
              <div>
                <p>
                  Recency Mode creates a temporally weighted briefing that automatically adjusts summary resolution based on when information appeared in your conversation. Think of it as a zoom lens that focuses sharper on recent events while maintaining a wide-angle view of the overall context.
                </p>
                <div>
                  <p>How It Works: Temporal Bands</p>
                  <p>
                    Recency Mode divides your conversation into three distinct chronological bands and changes how it processes each one by adjusting the "drone density" (the number of summarization jobs per chunk of text).
                  </p>
                  <ul>
                    <li><strong>Recent (Last 20%):</strong> Processed at High Resolution.<br/>
                    <span>The system deploys more, smaller drone jobs. This captures fine-grained details and specific facts from the end of the conversation.</span></li>
                    <li><strong>Mid (Middle 50%):</strong> Processed at Standard Resolution.<br/>
                    <span>This section receives normal processing, providing a balanced summary of the core discussion.</span></li>
                    <li><strong>Oldest (First 30%):</strong> Processed at Low Resolution.<br/>
                    <span>The system uses fewer, larger drone jobs. This forces it to create a high-level, thematic overview while discarding less critical early details.</span></li>
                  </ul>
                </div>
                <p>The Result:</p>
                <p>
                  Your context card begins with a high-level overview of earlier discussion, gradually increasing in detail as it approaches the present. This creates a natural narrative flow that mirrors how human memory works – general impressions of the past, vivid details of the present.
                </p>
                <p>Recency Strength Settings:</p>
                <ul>
                  <li><strong>Subtle:</strong> Gentle gradient. Maintains more detail throughout.</li>
                  <li><strong>Balanced:</strong> Standard temporal weighting. Ideal for most projects.</li>
                  <li><strong>Strong:</strong> Aggressive recency bias. Heavily focuses on latest developments.</li>
                </ul>
              </div>
            )}
          </div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('advanced')}
            >
              <Settings size={20} />
              <div>
                <h3>Advanced Controls</h3>
                <p>Fine-tuning the engine for specific missions.</p>
              </div>
              {expandedSections.advanced ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.advanced && (
              <div>
                <p>
                  These settings provide direct control over the cost, performance, and granularity of the condensation pipeline. Adjust them only if you understand the trade-offs.
                </p>
                <div>
                  <div>
                    <h4>LLM Temperature</h4>
                    <p>
                      Temperature controls the "randomness" or "creativity" of the drone's output. It's a value between 0.0 and 2.0.
                    </p>
                    <ul>
                      <li><strong>Low Temperature (e.g., 0.2 - 0.5):</strong> The drone will be more focused, deterministic, and predictable. Its summaries will be more like a factual report, sticking very closely to the source text.</li>
                      <li><strong>High Temperature (e.g., 0.8 - 1.2):</strong> The drone will take more creative risks. Its summaries may be more narrative, making interpretive leaps to connect ideas. This can result in a more readable, story-like output, but carries a higher risk of losing precision or introducing subtle inaccuracies.</li>
                    </ul>
                    <p>
                      For most technical summarization, a lower temperature is recommended.
                    </p>
                  </div>
                  <div>
                    <h4>Drone Density</h4>
                    <p>
                      This setting controls the "resolution" of the condensation process by defining how many drones are assigned per 10,000 tokens of source text.
                    </p>
                    <ul>
                      <li><strong>Low Density (e.g., 1-2):</strong> Each drone gets a large chunk of text. This is cheaper and results in a more high-level, thematic summary.</li>
                      <li><strong>High Density (e.g., 4-5):</strong> Each drone gets a smaller, more focused chunk. This is more expensive but results in a more detailed and granular context card.</li>
                    </ul>
                    <p>
                      <strong>Note:</strong> This setting is disabled when Recency Mode is active. Recency Mode uses its own dynamic logic to vary the drone density automatically.
                    </p>
                  </div>
                  <div>
                    <h4>Runaway Cost Protection (Max Drones)</h4>
                    <p>
                      This is a hard safety limit on the total number of drones a single job can create. Its primary purpose is to prevent accidental, runaway API costs when processing extremely large documents with a high Drone Density setting.
                    </p>
                    <p>
                      <strong>Recommendation:</strong> Only increase this limit if you are intentionally processing a massive session (e.g., 500k+ tokens) and have accepted the potential cost implications.
                    </p>
                  </div>
                </div>
              </div>
            )}
          </div>
          {}
          <div>
            <button
              onClick={() => onToggleSection('privacy')}
            >
              <Shield size={20} />
              <div>
                <h3>Privacy & The Project</h3>
                <p>Your Keys, Your Data.</p>
              </div>
              {expandedSections.privacy ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
            </button>
            {expandedSections.privacy && (
              <div>
                <p>
                  ThreadLink is built with a privacy-first, BYOK, open-source philosophy. Your conversations and API keys remain exclusively yours.
                </p>
                <div>
                  <p>BYOK (Bring Your Own Key) Architecture:</p>
                  <ul>
                    <li>Your API keys are never seen or stored by our servers</li>
                    <li>All API calls go directly from your browser to the LLM provider</li>
                    <li>No intermediary servers handle your sensitive data</li>
                    <li>Complete transparency in how your data flows</li>
                  </ul>
                </div>
                <p>
                  The complete ThreadLink source code is available on GitHub for review. You can see exactly how every feature works, verify our privacy claims, and even run your own instance if desired.
                </p>
                <div>
                  <p>
                    <a 
                      href="https://github.com/skragus/threadlink" 
                      target="_blank" 
                      rel="noopener noreferrer"
                    >
                      <strong>GitHub:</strong> github.com/skragus/threadlink - yes, I'd like a star
                    </a>
                  </p>
                </div>
              </div>
            )}
          </div>
        </div>
        {}
        <div>
          <button
            onClick={onClose}
          >
            Got it, thanks!
          </button>
        </div>
      </div>
    </div>
  );
};
InfoPanel;

// FILE: components/LoadingOverlay.tsx
// components/LoadingOverlay.tsx - Loading Overlay Component
const LoadingOverlay: React.FC<LoadingOverlayProps> = ({
  loadingProgress,
  isCancelling,
  onCancel
}) => {
  const progressBarRef = useRef<HTMLDivElement>(null);
  // Update progress bar width
  useEffect(() => {
    if (progressBarRef.current && loadingProgress.totalDrones && loadingProgress.totalDrones > 0) {
      const progressPercent = Math.min(100, ((loadingProgress.completedDrones || 0) / loadingProgress.totalDrones) * 100);
      progressBarRef.current.style.width = `${progressPercent}%`;
    }
  }, [loadingProgress.completedDrones, loadingProgress.totalDrones]);
  return (
    <div>
      <div>
        <div>
          {}
          <div>
            <div>
              {loadingProgress.message}
            </div>
            {loadingProgress.elapsedTime !== undefined && (
              <div>
                {loadingProgress.elapsedTime.toFixed(1)}s elapsed
              </div>
            )}
          </div>
          {}
          {loadingProgress.phase === 'processing' && loadingProgress.totalDrones && (
            <div>
              <div>
                <span>Progress: {loadingProgress.completedDrones || 0}/{loadingProgress.totalDrones} drones</span>
                <span>{Math.round(((loadingProgress.completedDrones || 0) / loadingProgress.totalDrones) * 100)}%</span>
              </div>
              <div>
                <div 
                  ref={progressBarRef}
                />
              </div>
            </div>
          )}
          {}
          {loadingProgress.phase !== 'processing' && (
            <div>
              <Loader2 size={24} />
            </div>
          )}
          {}
          <button
            onClick={onCancel}
            disabled={isCancelling || loadingProgress.phase === 'finalizing'}
          >
            {isCancelling ? 'Cancelling...' : 'Cancel'}
          </button>
        </div>
      </div>
    </div>
  );
};
LoadingOverlay;

// FILE: components/SettingModal.tsx
// components/SettingsModal.tsx - Settings Modal Component
const SettingsModal: React.FC<SettingsModalProps> = ({
  isOpen,
  model,
  setModel,
  processingSpeed,
  setProcessingSpeed,
  recencyMode,
  setRecencyMode,
  recencyStrength,
  setRecencyStrength,
  showAdvanced,
  setShowAdvanced,
  advTemperature,
  setAdvTemperature,
  advDroneDensity,
  setAdvDroneDensity,
  advMaxDrones,
  setAdvMaxDrones,
  onClose
}) => {
  if (!isOpen) return null;
  const isAnthropicModel = model.includes('claude');
  const showProcessingSpeed = !isAnthropicModel;
  return (
    <div>
      <div>
        <h3>Settings</h3>
        <div>
          {}
          <div>
            <div>
              <label htmlFor="model-select">
                Model
              </label>
            </div>
            <select
              id="model-select"
              value={model}
              onChange={(e) => setModel(e.target.value)}
            >
              <optgroup label="Google">
                <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                <option value="gemini-pro">Gemini Pro</option>
              </optgroup>
              <optgroup label="OpenAI">
                <option value="gpt-4">GPT-4</option>
                <option value="gpt-4o">GPT-4o</option>
                <option value="gpt-4o-mini">GPT-4o Mini</option>
                <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
              </optgroup>
              <optgroup label="Anthropic">
                <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet</option>
                <option value="claude-3-5-haiku-20241022">Claude 3.5 Haiku</option>
                <option value="claude-3-haiku-20240307">Claude 3 Haiku</option>
                <option value="claude-3-opus-20240229">Claude 3 Opus</option>
              </optgroup>
            </select>
          </div>
          {}
          {showProcessingSpeed && (
            <div>
              <div>
                <label>
                  Processing Speed
                </label>
                <div>
                  <div>
                    i
                  </div>
                  <div>
                    Fast mode uses higher concurrency for faster processing
                  </div>
                </div>
              </div>
              <div>
                <span`}>
                  Normal
                </span>
                <button
                  onClick={() => setProcessingSpeed(processingSpeed === 'balanced' ? 'fast' : 'balanced')}
                  title={`Switch to ${processingSpeed === 'balanced' ? 'fast' : 'balanced'} processing`}`}
                >
                  <span`}
                  />
                </button>
                <span`}>
                  Fast
                </span>
              </div>
            </div>
          )}
          {}
          <div>
            <div>
              <label>
                Recency Mode
              </label>
              <div>
                <div>
                  i
                </div>
                <div>
                  Prioritizes more recent content in conversations
                </div>
              </div>
            </div>
            <div>
              <span`}>
                Off
              </span>
              <button
                onClick={() => setRecencyMode(!recencyMode)}
                title={`${recencyMode ? 'Disable' : 'Enable'} recency mode`}`}
              >
                <span`}
                />
              </button>
              <span`}>
                On
              </span>
            </div>
          </div>
          {}
          {recencyMode && (
            <div>
              <div>
                <label>
                  Recency Strength
                </label>
                <div>
                  <div>
                    i
                  </div>
                  <div>
                    How strongly to weight recent vs older content
                  </div>
                </div>
              </div>
              <div>
                <input
                  type="range"
                  min="0"
                  max="2"
                  step="1"
                  value={recencyStrength}
                  onChange={(e) => setRecencyStrength(parseInt(e.target.value))}
                  title="Adjust recency strength"
                />
                <div>
                  <span>Subtle</span>
                  <span>Balanced</span>
                  <span>Strong</span>
                </div>
              </div>
            </div>
          )}
          {}
          <div>
            <button
              onClick={() => setShowAdvanced(!showAdvanced)}
            >
              {showAdvanced ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
              <span>Advanced Settings</span>
            </button>
            {showAdvanced && (
              <div>
                {}
                <div>
                  <div>
                    <label htmlFor="adv-temperature">
                      LLM Temperature
                    </label>
                    <div>
                      <div>
                        i
                      </div>
                      <div>
                        Controls creativity. 0.2 = deterministic, 1.0 = creative
                      </div>
                    </div>
                  </div>
                  <input
                    id="adv-temperature"
                    type="number"
                    min="0"
                    max="2"
                    step="0.1"
                    value={advTemperature}
                    onChange={(e) => setAdvTemperature(parseFloat(e.target.value))}
                  />
                </div>
                {}
                {!recencyMode && (
                  <div>
                    <div>
                      <label htmlFor="adv-drone-density">
                        Drone Density
                      </label>
                      <div>
                        <div>
                          i
                        </div>
                        <div>
                          Drones per 10k tokens. Controls cost vs. granularity
                        </div>
                      </div>
                    </div>
                    <input
                      id="adv-drone-density"
                      type="number"
                      min="1"
                      max="20"
                      step="1"
                      value={advDroneDensity}
                      onChange={(e) => setAdvDroneDensity(parseInt(e.target.value))}
                    />
                  </div>
                )}
                {}
                <div>
                  <div>
                    <div>
                      <label htmlFor="adv-max-drones">
                        Max Drones Limit
                      </label>
                      <div>
                        <div>
                          i
                        </div>
                        <div>
                          Hard safety limit on total drones per job
                        </div>
                      </div>
                    </div>
                    <input
                      id="adv-max-drones"
                      type="number"
                      min="10"
                      max="200"
                      step="10"
                      value={advMaxDrones}
                      onChange={(e) => setAdvMaxDrones(parseInt(e.target.value))}
                    />
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
        <div>
          <button
            onClick={onClose}
          >
            Save
          </button>
          <button
            onClick={onClose}
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};

// FILE: components/TextEditor.tsx
// components/TextEditor.tsx - Text Editor Component
const TextEditor: React.FC<TextEditorProps> = ({
  displayText,
  isLoading,
  isProcessed,
  error,
  stats,
  loadingProgress,
  isCancelling,
  errorRef,
  statsRef,
  outputTextareaRef,
  onTextChange,
  onCancel
}) => {
  return (
    <>
      {}
      {error && (
        <div ref={errorRef}>
          {error}
        </div>
      )}
      {}
      {stats && (
        <div ref={statsRef}>
          Processed in {stats.executionTime}s • {stats.compressionRatio}:1 compression • {stats.successfulDrones}/{stats.totalDrones} drones successful
        </div>
      )}
      {}
      <div>
        <textarea
          ref={outputTextareaRef} ${isProcessed || isLoading ? 'cursor-default' : 'cursor-text'}`}
          placeholder="Paste your AI conversation here..."
          value={displayText}
          onChange={onTextChange}
          readOnly={isProcessed || isLoading}
        />
        {}
        <a 
          href="https://bolt.new" 
          target="_blank" 
          rel="noopener noreferrer"
        >
          <img 
            src="src/assets/bolt-badge.png"
            alt="Powered by Bolt.new"
          />
        </a>
        {}
        {isLoading && (
          <LoadingOverlay 
            loadingProgress={loadingProgress}
            isCancelling={isCancelling}
            onCancel={onCancel}
          />
        )}
      </div>
    </>
  );
};
TextEditor;